

using Toybox.Graphics;
using Toybox.Lang;
using Toybox.Math;
using Toybox.System;
using Toybox.Time;
using Toybox.Time.Gregorian;
using Toybox.WatchUi;
using Toybox.Application;

var partialUpdatesAllowed = false;

class SliderView extends WatchUi.WatchFace
{
    var font1;
    var font_min;
    var font_min1;
    var font_min2;
    var font_max;
    var isAwake;
    var screenShape;
    var dndIcon;
    var offscreenBuffer;
    var dateBuffer;
    var curClip;
    var screenCenterPoint;
   // var screenHalfPoint;
    var fullScreenRefresh;
    var is24hour;
  
	var fontSize;
	var tempUnits;
	 
    var BgColor;
    var BrColor;   
    var DtColor;
    var FgColor;
    var ThemeColor;
    var ShowBatteryBar;
    var StepCals;
 	var chosenFields;
	var displaySeconds;

	 var dtVecTxt ;
	 var dtVecNum ; 
	 var hourVecTxt;
	 var minVecTxt;
	 var DateDot;
	 var DateThick;
	var MinThick ;
	var MinPoint ;	 
	var	StepThick;
	var	StepDot;						
	var BatBarStatic;
	var StepTxt;	
	var ClockFont; 
	var ClockFont1; 
		var ClockFont2; 
	var bgRedrawRequested;	
	var BgDrawn;
	var offlineFieldValues;//;// = new[6];
	var offCalcBuffer;
	var offCalcField1;
	var offCalcField6;
	var sRenderer;
	var tRenderer;
	var iKeeper;
	var myDc;

    function initialize() {
        WatchFace.initialize();
        screenShape = System.getDeviceSettings().screenShape;
        fullScreenRefresh = true;
        offlineFieldValues = new[15];
       
     
        partialUpdatesAllowed = ( Toybox.WatchUi.WatchFace has :onPartialUpdate );
    }

    // Configure the layout of the watchface for this device
    function onLayout(dc) {

        font_min1 = WatchUi.loadResource(Rez.Fonts.mari_font_min);
         font_min2 = WatchUi.loadResource(Rez.Fonts.mari_font_min2);
        ClockFont1 = WatchUi.loadResource(Rez.Fonts.teko);
 		ClockFont2 = WatchUi.loadResource(Rez.Fonts.mari_font_max);
 		screenCenterPoint = [dc.getWidth()/2, dc.getHeight()/2];
 		bgRedrawRequested = new[2];
 		 sRenderer = new symbolRenderer(dc);
 		  tRenderer = new textRenderer(dc);
 		  iKeeper = new infoKeeper();
 		   isAwake = true;
 		  

   

	}
    // Handle the update event
    function onUpdate(dc) {
        var width;
        var height;
        var screenWidth = dc.getWidth();
        var clockTime = System.getClockTime();
        var minuteHandAngle;
        var hourHandAngle;
        var secondHand;
        var targetDc = null;
        var curClip = null;
        myDc = dc;
       // isAwake = true;
     		 getColorSettings();
 		 sRenderer._themeColor = ThemeColor;
 		 sRenderer._bgColor = BgColor;  
 		 tRenderer.fgColor = FgColor;
 		 tRenderer.bgColor = BgColor;   		   
        
         chosenFields = [1,2,3,4,5,6];
         
         getFields ();
         
          /*
               order in settings defined:       Steps,Calories,Temperature,Battery,HeartRate,Floors,Altitude,Messages
          */
         ShowBatteryBar = false; 
         
         is24hour = System.getDeviceSettings().is24Hour;
         tempUnits = System.getDeviceSettings().temperatureUnits ;

		 
		// fullScreenRefresh = true;
 		drawBackground(dc);

        if(Application.getApp().getProperty("displaySeconds") != null)
        {
        displaySeconds = Application.getApp().getProperty("displaySeconds");
        }   
        else
        	{
        	Application.getApp().setProperty("displaySeconds", displaySeconds);
        	} 	
         //System.println("seconds_display are set to: "+displaySeconds);	
        //wyœwietlanie sekund
        
       
        

				    	if(isAwake and displaySeconds==true)
				    		{
				    		 var secs = System.getClockTime().sec;
				    		drawSeconds(dc,ThemeColor,secs);
				    		
				    		}

     

        

    }

    function drawBackground(dc) {
     	 if(true)//fullScreenRefresh==true)
     	 {
     	// System.println("imma drawinn full");
     	dc.clearClip(); 
        dc.setColor(BgColor, BgColor);
		dc.clear();
		dc.setColor(BgColor, BgColor);
		dc.fillRectangle(0, 0, dc.getWidth(), dc.getHeight());
		
		dc.setPenWidth(2);

		drawHours(dc,FgColor);
		drawMinutes(dc,FgColor);
		drawFields(dc,FgColor);
		//fullScreenRefresh = false;
			}
		//todo
		//steps
		//calories
		//heart rate
		//altitude



 
    }
	
	function drawMinutes(dc,Color)	{

	var minutes = System.getClockTime().min.format("%02d");

 
	var fsize = dc.getHeight()/4;
	//var fsize = Math.floor(dc.getWidth()/2.54);
	var y = dc.getHeight()/2+fsize/2;
	var x = dc.getWidth()/2+5 ;
	tRenderer.fgColor = ThemeColor;
	//renderText(dc,x,y,fsize,minutes,ThemeColor);
	tRenderer.renderText(x,y,fsize,minutes);
	tRenderer.fgColor = FgColor;
	}
	
	function drawHours(dc,Color)	{
	
	
	var today = Gregorian.info(Time.now(), Time.FORMAT_SHORT );
	var months = today.month;
	if(months<10)
		{
		months = "0"+months.toString();
		}
		months.toString();
	var daten =  today.day.toString()+months;
	//System.println(daten);	
	
	var hours = System.getClockTime().hour.format("%02d");
	
	var onehour = new Time.Duration(3600);
	var currenth = new Gregorian.Moment(Time.now().value());
	var hourLater =  Gregorian.info(currenth.add(onehour),Time.FORMAT_MEDIUM).hour.format("%02d");
	var hourBefore = Gregorian.info(currenth.subtract(onehour),Time.FORMAT_MEDIUM).hour.format("%02d");
	
	var fsize = Math.floor(dc.getWidth()/2.54);
	//System.println("gotta:"+fsize);
	var y = dc.getHeight()/2+fsize/2;
	var yb = dc.getHeight()/2-fsize*0.5-Math.floor(fsize/10.0);
	var ymon = dc.getHeight()/2-fsize*0.5-Math.floor(fsize/10.0);
	var yday = dc.getHeight()/2-fsize-Math.floor(fsize/10.0);
	var ya = dc.getHeight()/2+fsize*1.5+Math.floor(fsize/10.0);
	//System.println("dc height 2="+(dc.getHeight()/2.0)+", fsize*0.5="+(fsize*0.5)+"fsize*1.5="+(fsize*1.5)+"fsize 10="+Math.floor(fsize/10.0)+"!!");
	var x = dc.getWidth()/2-hours.length()*fsize/2.0-fsize/20-5;
	var xd = dc.getWidth()/2-hours.length()*fsize/4-fsize/20-5;
	var x2 = dc.getWidth()/2-5;	
	//coords
	
	//

	//dc.setColor(Color,BgColor);
	//renderText(dc,x,y,fsize,hours,ThemeColor);
	//renderText(dc,x,yb,fsize,hourBefore,Color);
	//renderText(dc,x,ya,fsize,hourLater,Color);
	tRenderer.fgColor = FgColor;
	tRenderer.renderText(x,y,fsize,hours);


	//System.println(daten);
	//tRenderer.renderText(x,yb,fsize,hourBefore);
	tRenderer.renderText(xd,ymon,fsize/3,months);
	tRenderer.renderText(xd,yday,fsize/3,today.day.toString());
	
	
	tRenderer.renderText(x,ya,fsize,hourLater);
	
	
	RenderShade(dc,x,yb-fsize,x2,yb,BgColor,Color);
	
	
	RenderShade(dc,x,ya-fsize,x2,ya,BgColor,Color);
	//renderText(dc,40,yb,Math.floor(fsize/6.0),daten.toString(),FgColor);
	offCalcBuffer = [[x,y,fsize,hours,ThemeColor],[x,yb,fsize,hourBefore,Color],[x,ya,fsize,hourLater,Color]];
	}	
	
	
	function drawHoursoffCalc(dc,x,y,fsize,hours,shade,Color) {
	//System.println("drawin"+hours+"with"+shade+" shade");
		dc.setColor(Color,BgColor);	
		//renderText(dc,x,y,fsize,hours,Color);
		tRenderer.renderText(x,y,fsize,hours);
		if(shade==true)
			{
			RenderShade(dc,x,y-fsize,dc.getWidth()/2-5,y,BgColor,Color);
			}	
			if(curClip !=null)
				{
				//System.println("drawin"+hours+"with clip set");
				}
	
		}


	
function drawSeconds(dc,Color,secs)	{ 
		
		if (secs==59)
			{
			fullScreenRefresh=true;
			}
		//cleaning part
 			miniBgRedraw(Color,secs);
			
			//drawBackground(dc);
		
		
		var secondsAngle = (secs/60.0) * Math.PI * 2;
		if(secs>30)
			{
			secondsAngle = ((60-secs)/60.0) * Math.PI * 2;
			}
		
		var thick = generateSecondsThicks(screenCenterPoint,secondsAngle,5);
		
		////now dc restrict
		       curClip = getBoundingBox(thick);
		
		//dc.setColor(Graphics.COLOR_RED, Graphics.COLOR_TRANSPARENT);    
		dc.setColor(Graphics.COLOR_RED, Graphics.COLOR_TRANSPARENT);     
		      //System.println(secs);
		      //  var bboxWidth = curClip[1][0] - curClip[0][0];
		       // var bboxHeight = curClip[1][1] - curClip[0][1];
		        //dc.drawRectangle(curClip[0][0], curClip[0][1], bboxWidth, bboxHeight);
		       	 dc.setClip(curClip[0][0], curClip[0][1], curClip[1], curClip[2]); 
		        if((secs>29 and secs<31))
		        	{
		        	bgRedrawRequested[0] = 1;
		        	}  
		        else if((secs>59 or secs<1))
		        	{
		        	bgRedrawRequested[0] = 3;
		        	} 
		        else {
		        	bgRedrawRequested[0] = 0;
		        	} 
		        			        	
		       	if((secs>3 and secs<8) or (secs>52 and secs<57))// drawOffCalcField(DrawContext,x,y,fontSize,fieldType,FieldColor,value,fieldno)
		        	{
		        	
		        	bgRedrawRequested[1] = 1;
		        	} 
		        else if((secs>22 and secs<27) or (secs>33 and secs<38)) {
		        bgRedrawRequested[1] = 2;
		        }
		        	
				       	else
				        	{
				        	bgRedrawRequested[1] = 0;
				        	} 	        		
		        
		//
		dc.setColor(ThemeColor, Graphics.COLOR_TRANSPARENT);
		dc.setPenWidth(2);
		DrawPolygon(dc,thick[0]);
		DrawPolygon(dc,thick[1]);

		//System.println(bgRedrawRequested);
		//System.println("secs_draw"+secs);
}	
	
	function drawFields(dc,FieldColor) {
        // chosenFields = [1,2,3,4,5,6];
       
        //Steps,Calories,Temperature,Battery,HeartRate,Floors,Altitude,Messages	
        dc.setPenWidth(1);
     var x = dc.getWidth()/2+5;
     var y =0;  
     var z=2;
     var fsize = 16;//dc.getHeight()/20.0; 
		     for(var i =0;i<chosenFields.size();i++) {
		     //wez wartoœæ pola
		   	
		      y = dc.getHeight()/6.0+i*fsize*1.4;
		      if(i>2)
		      	{
		      	//minute font size = dc.getHeight()/4
		    y = dc.getHeight()- dc.getHeight()/6.0-z*fsize*1.4+fsize;
		      z--;
		      	}
		      //	System.println("drawin field "+chosenFields[i]+" on y:"+y);
		     		drawField(dc,x,y,chosenFields[i],FieldColor,fsize,i);
		     //narysuj pole
		     
		     }
	
	
	}	
	
	function drawField(DrawContext,x,y,fieldType,FieldColor,fontSize,fieldno) {
	//Steps,Calories,Temperature,Battery,HeartRate,Floors,Altitude,Messages	
	var value =0;
		if(fullScreenRefresh==true)
		{
		value = iKeeper.getFieldValue(fieldType);
		offlineFieldValues[fieldType]=value;
		}
		else {
		value = offlineFieldValues[fieldType];
			}
		//System.println("gettin field"+fieldType+"got"+value);

	//renderSymbol(DrawContext,x,y,fontSize,fieldType,FieldColor);
	sRenderer.renderSymbol(x,y,fontSize,fieldType,FieldColor);
//	renderText(DrawContext,x+fontSize+5,y,fontSize,value.toString(),FieldColor);
	tRenderer.renderText(x+fontSize+5,y,fontSize,value.toString());

				if ( fieldno==0)
				{
					offCalcField1 = [DrawContext,x,y,fontSize,fieldType,FieldColor,value];
					}
				if ( fieldno==5)
				{
					 offCalcField6 = [DrawContext,x,y,fontSize,fieldType,FieldColor,value];
					}					
	
	}
	function drawOffCalcField(DrawContext,x,y,fontSize,fieldType,FieldColor,value) {
			sRenderer.renderSymbol(x,y,fontSize,fieldType,FieldColor);
			//renderText(DrawContext,x+fontSize+5,y,fontSize,value.toString(),FieldColor);
			tRenderer.renderText(x+fontSize+5,y,fontSize,value.toString());
			//System.println("drawin fields with clip set");	
	}
	
		function RenderShade(dc,x1,y1,x2,y2,Bg,Fg) {
		
		if(curClip != null and fullScreenRefresh==false)
			{
			if(x2>curClip[0][0]+curClip[1]){
			x2=curClip[0][0]+curClip[1];
				}
			if(y2>curClip[0][1]+curClip[2]){
			y2=curClip[0][1]+curClip[2];
				}				
			}		
		x1--;
		y1--;
		x2++;
		y2++;
		dc.setColor(Bg, Bg);
		dc.setPenWidth(1);

		for(var i=x1;i<x2;i++)
			{
			
			dc.drawLine(i, y1, i, y2);
			i++;
			
			}
		for(var j=y1;j<y2;j++)
			{
			dc.drawLine(x1, j, x2, j);
			j++;
			}		
		
		
}
	



function DrawPolygon(DrawContext,polygon) {
		for(var i=1;i<polygon.size();i++)
			{
			DrawContext.drawLine(polygon[i-1][0], polygon[i-1][1], polygon[i][0], polygon[i][1]);
			}
}
	
 


	function dayOfWeek(day) {
	
	var days = [1, 2, 3, 4, 5, 6, 7, 8];
	days[0]=null;
	days[1]="Sunday";
	days[2]="Monday";
	days[3]="Tuesday";
	days[4]="Wednesday";
	days[5]="Thursday";
	days[6]="Friday";
	days[7]="Saturday";
	
	return days[day].substring(0,3);

	}		
 


 
 
 
 
	function getColorSettings() {
        if(Application.getApp().getProperty("BackgroundColor") != null)
        {
        BgColor = Application.getApp().getProperty("BackgroundColor");
        }
        else
        	{
        	Application.getApp().setProperty("BackgroundColor", BgColor);
        	}
        	 
      	if(Application.getApp().getProperty("ForegroundColor") != null)
        {
        FgColor = Application.getApp().getProperty("ForegroundColor");
        }
        else
        	{
        	Application.getApp().setProperty("ForegroundColor", FgColor);
        	}      
        if(Application.getApp().getProperty("ThemeColor") != null)
        {
        ThemeColor = Application.getApp().getProperty("ThemeColor");
        
        }   
        else
        	{
        	Application.getApp().setProperty("ThemeColor", ThemeColor);
        	}	
	
	}

	
    // Handle the partial update event

    // Compute a bounding box from the passed in points
    function getBoundingBox(array) {
   var minX=array[0][0][0];
   var minY=array[0][0][1];
   var maxX=array[0][0][0];
   var maxY=array[0][0][1];
   
		 for(var i=0;i<array.size();i++){
		 
			 for(var j=0;j<array[i].size();j++)
			 	{
					if(array[i][j][0]<minX)
					 	{
					 	minX = array[i][j][0];
					 	}
					 if(array[i][j][1]<minY)
					 	{
					 	minY = array[i][j][1];
					 	}
					 if(array[i][j][0]>maxX)
					 	{
					 	maxX = array[i][j][0];
					 	}
					 if(array[i][j][1]>maxY)
					 	{
					 	maxY = array[i][j][1];
					 	}						 			 	
			 	}
			 

		 		 	
		 
		 
		 
		 }
		 //		        var bboxWidth = curClip[1][0] - curClip[0][0];
		 //        var bboxHeight = curClip[1][1] - curClip[0][1];
		 var width = maxX+3- minX+3;
		 var height = maxY+3- minY+3;
        return [[minX-3,minY-3], width,height];
    }
  

 
    function generateSecondsThicks(centerPoint, angle, handLength) {
        // Map out the coordinates of the watch hand
        var ThickLen = 12;
        var yMax = centerPoint[1];
        var cP = centerPoint;
        angle = angle+Math.PI/2;

        var coords1 = [[-3,-yMax+ThickLen],[-3,-yMax]];
        //var coords2 = [[0,-yMax+ThickLen],[0,-yMax]];
        var coords3 = [[3,-yMax+ThickLen],[3,-yMax]];
        
        var cos = Math.cos(angle);
        var sin = Math.sin(angle);
        var ret = new[2];
        //System.println([cos,sin,angle]);

        // Transform the coordinates
       // var result1 = [[cP[0]+  coords1[0][1]*cos-sin,	cP[1]+coords1[0][1]*sin+cos ]     ,   [cP[0]+coords1[1][1]*cos-sin,	cP[1]+coords1[1][1]*sin+cos]];
        var result1 = [[cP[0]+  coords1[0][1]*cos+coords1[0][0]*sin,	cP[1]+coords1[0][1]*sin-coords1[0][0]*cos ]     ,  
        		 [cP[0]+coords1[1][1]*cos+coords1[1][0]*sin,	cP[1]+coords1[1][1]*sin-coords1[1][0]*cos]];
        /*var result2 = [[cP[0]+  coords2[0][1]*cos+coords2[0][0]*sin,	cP[1]+coords2[0][1]*sin-coords2[0][0]*cos ]     ,  
        		 [cP[0]+coords2[1][1]*cos+coords2[1][0]*sin,	cP[1]+coords2[1][1]*sin-coords2[1][0]*cos]];   */  
        var result3 = [[cP[0]+  coords3[0][1]*cos+coords3[0][0]*sin,	cP[1]+coords3[0][1]*sin-coords3[0][0]*cos ]     ,  
        		 [cP[0]+coords3[1][1]*cos+coords3[1][0]*sin,	cP[1]+coords3[1][1]*sin-coords3[1][0]*cos]];         		    	
        //var result1 = [[cP[0]+(yMax-ThickLen)*cos-sin,	cP[1]+(yMax-ThickLen)*sin+cos ]     ,   [cP[0]+yMax*cos-sin,	cP[1]+yMax*sin]+cos];
        
        return [result1,result3];
    } 
    
function miniBgRedraw(Color,secs)
{
		if(curClip !=null)
			{
			myDc.setColor(BgColor,BgColor);
			myDc.fillRectangle(curClip[0][0], 
								curClip[0][1], 
								curClip[1] , 
								curClip[2]);
			}
			
			if(bgRedrawRequested[0]==1)///low
				{
				//dc.drawRectangle(curClip[0][0], curClip[0][1], bboxWidth, bboxHeight);
				drawHoursoffCalc(myDc,offCalcBuffer[2][0],offCalcBuffer[2][1],offCalcBuffer[2][2],offCalcBuffer[2][3],true,offCalcBuffer[2][4]);
				}
			if(bgRedrawRequested[0]==3)///top
				{
				//dc.drawRectangle(curClip[0][0], curClip[0][1], bboxWidth, bboxHeight);
				drawHoursoffCalc(myDc,offCalcBuffer[1][0],offCalcBuffer[1][1],offCalcBuffer[1][2],offCalcBuffer[1][3],true,offCalcBuffer[1][4]);
				}
			if(bgRedrawRequested[1]==1)
				{
				//dc.drawRectangle(curClip[0][0], curClip[0][1], bboxWidth, bboxHeight);
				//drawFields(dc,FgColor);
				
				//offCalcField1 = [DrawContext,x,y,fontSize,fieldType,FieldColor,value];
				drawOffCalcField(offCalcField1[0],offCalcField1[1],offCalcField1[2],offCalcField1[3],offCalcField1[4],offCalcField1[5],offCalcField1[6]);
				}
			if(bgRedrawRequested[1]==2)
				{
				//dc.drawRectangle(curClip[0][0], curClip[0][1], bboxWidth, bboxHeight);
				//drawFields(dc,FgColor);
				drawOffCalcField(offCalcField6[0],offCalcField6[1],offCalcField6[2],offCalcField6[3],offCalcField6[4],offCalcField6[5],offCalcField6[6]);
				}	
			
				//System.println("bg_secs_clear"+secs);
}    


    // This method is called when the device re-enters sleep mode.
    // Set the isAwake flag to let onUpdate know it should stop rendering the second hand.
    function onEnterSleep() {
       
        var secs =System.getClockTime().sec;
        curClip = null;
        myDc.clearClip();
        myDc.clear();
        WatchUi.requestUpdate();
       

        fullScreenRefresh = false;
         isAwake = false;
      System.println("sleepin, secs="+secs);
    }

    // This method is called when the device exits sleep mode.
    // Set the isAwake flag to let onUpdate know it should render the second hand.
    function onExitSleep() {
        isAwake = true;
        fullScreenRefresh = true;
       //  System.println("imma wakin");


//WatchUi.animate(myString, 50, WatchUi.ANIM_TYPE_LINEAR, 10, 200, 10, null);
        
    }
    function getFields () {
    
   
    var j=0;
   
    for(var i=0;i<6;i++)
    {
    j++;
	     if(Application.getApp().getProperty("Field_"+j) != null) { 
		     	chosenFields[i] = Application.getApp().getProperty("Field_"+j);
		     	}
	         	else{Application.getApp().setProperty("Field_"+j, chosenFields[i]);
	         	} 
	         	
	     }        	         	         	         	         	         	
    }
    function onPartialUpdate(dc) {
     
		
		if( displaySeconds==true) {
		 var seconds = System.getClockTime().sec;
	//	System.println("imma doin partial update");
	drawSeconds(dc,ThemeColor, seconds);  
	}
	//System.println("partial, secs="+seconds);
    
    }		     
}
class SliderViewDelegate extends WatchUi.WatchFaceDelegate {
    // The onPowerBudgetExceeded callback is called by the system if the
    // onPartialUpdate method exceeds the allowed power budget. If this occurs,
    // the system will stop invoking onPartialUpdate each second, so we set the
    // partialUpdatesAllowed flag here to let the rendering methods know they
    // should not be rendering a second hand.
    function onPowerBudgetExceeded(powerInfo) {
        System.println( "Average execution time: " + powerInfo.executionTimeAverage );
        System.println( "Allowed execution time: " + powerInfo.executionTimeLimit );
        partialUpdatesAllowed = false;
    }
}
