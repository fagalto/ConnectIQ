

using Toybox.Graphics;
using Toybox.Lang;
using Toybox.Math;
using Toybox.System;
using Toybox.Time;
using Toybox.Time.Gregorian;
using Toybox.WatchUi;
using Toybox.Application;
using Toybox.SensorHistory;


var partialUpdatesAllowed = false;

class SliderView extends WatchUi.WatchFace
{
    var font1;
    var font_min;
    var font_min1;
    var font_min2;
    var font_max;
    var isAwake;
    var screenShape;
    var dndIcon;
    var offscreenBuffer;
    var dateBuffer;
    var curClip;
    var screenCenterPoint;
   // var screenHalfPoint;
    var fullScreenRefresh;
    var is24hour;
 
	var fontSize;
	var tempUnits;
	 
    var BgColor;
    var BrColor;   
    var DtColor;
    var FgColor;
    var ShowBatteryBar;
    var StepCals;

	var displaySeconds;

	 var dtVecTxt ;
	 var dtVecNum ; 
	 var hourVecTxt;
	 var minVecTxt;
	 var DateDot;
	 var DateThick;
	var MinThick ;
	var MinPoint ;	 
	var	StepThick;
	var	StepDot;						
	var BatBarStatic;
	var StepTxt;	
	var ClockFont; 
	var ClockFont1; 
		var ClockFont2; 	
	 
	 
	 
	 
    // Initialize variables for this view
    function initialize() {
        WatchFace.initialize();
        screenShape = System.getDeviceSettings().screenShape;
        fullScreenRefresh = true;
        partialUpdatesAllowed = ( Toybox.WatchUi.WatchFace has :onPartialUpdate );
    }

    // Configure the layout of the watchface for this device
    function onLayout(dc) {

        // Load the custom font we use for drawing the 3, 6, 9, and 12 on the watchface.
       // font1 = WatchUi.loadResource(Rez.Fonts.mari_font);
        font_min1 = WatchUi.loadResource(Rez.Fonts.mari_font_min);
         font_min2 = WatchUi.loadResource(Rez.Fonts.mari_font_min2);
        ClockFont1 = WatchUi.loadResource(Rez.Fonts.teko);
 		ClockFont2 = WatchUi.loadResource(Rez.Fonts.mari_font_max);

        // If this device supports the Do Not Disturb feature,
        // load the associated Icon into memory.


	}
    // Handle the update event
    function onUpdate(dc) {
        var width;
        var height;
        var screenWidth = dc.getWidth();
        var clockTime = System.getClockTime();
        var minuteHandAngle;
        var hourHandAngle;
        var secondHand;
        var targetDc = null;
         ShowBatteryBar = false; 
         
         is24hour = System.getDeviceSettings().is24Hour;
         tempUnits = System.getDeviceSettings().temperatureUnits ;
         BgColor = 0x000000;
		 FgColor = 0xFFFFFF;
 		drawBackground(dc);
	



        if( partialUpdatesAllowed && displaySeconds==true) {
        dc.clearClip();
       
		         var seconds = System.getClockTime().sec;
		           //System.println("update "+seconds);
				var minutes = System.getClockTime().min;
				if(minutes%2!=0)
					{
							seconds = 60-seconds;
						} 
		     // drawSeconds(dc,BrColor, seconds);
        } else if ( isAwake ) {
            // Otherwise, if we are out of sleep mode, draw the second hand
            // directly in the full update method.
           // dc.setColor(Graphics.COLOR_RED, Graphics.COLOR_TRANSPARENT);
           // secondHand = (clockTime.sec / 60.0) * Math.PI * 2;
        }

        fullScreenRefresh = false;

    }

    // Draw the date string into the provided buffer at the specified location

	

	
	 //dc.drawLine(dc.getWidth()/2, BbarY, 168 ,BbarY);
	
	function drawMinutes(dc,Color)	{
	var hour = System.getClockTime().hour;
	dc.setColor(Color,BgColor);
	dc.drawText(150, 150, Graphics.FONT_MEDIUM,hour, Graphics.TEXT_JUSTIFY_VCENTER);
	//System.println("imma drawin"+hour);


	}
	function drawSteps(dc,Color,StepCals)	{

	}
	function trueHours(hours)	{
	var truehours = hours;
	if(is24hour==false)
		{
		if(hours<0)
			{
			truehours = hours+12;
			}
		if(hours>12)
			{
			truehours = hours-12;
			}	
			if(truehours<10)
			{
			truehours =  "0"+truehours;
			}		
		}
		else
		
		{
		if(hours<0)
			{
			truehours = hours+24;
			}
		if(hours>=24)
			{
			truehours = hours-24;
			}	
			if(truehours<10)
			{
			truehours =  "0"+truehours;
			}
		}
		return truehours;	
	
	}
		function trueHours2(hours)	{
	var truehours = hours;

		if(hours<0)
			{
			truehours = hours+24;
			}
		if(hours>=24)
			{
			truehours = hours-24;
			}	
			if(truehours<10)
			{
			truehours =  "0"+truehours;
			}
		
		return truehours;	
	
	}
		function trueSeconds(number)	{
	var trueseconds = number;

		if(number<0)
			{
			trueseconds = number+60;
			}
		if(number>=60)
			{
			trueseconds = number-60;
			}	
			if(trueseconds<10)
			{
			trueseconds =  "0"+trueseconds;
			}
		
		return trueseconds;	
	
	}	
	function dayOfWeek(day) {
	
	var days = [1, 2, 3, 4, 5, 6, 7, 8];
	days[0]=null;
	days[1]="Sunday";
	days[2]="Monday";
	days[3]="Tuesday";
	days[4]="Wednesday";
	days[5]="Thursday";
	days[6]="Friday";
	days[7]="Saturday";
	
	return days[day].substring(0,3);

	}		
	function drawDate(dc, Color)	{
	
	}


	function drawBatteryStatic(dc,bw) {
	//BatBarStatic;
	
		if(BatBarStatic != null) {
		dc.setPenWidth(bw);
		 dc.setColor(BatBarStatic[4] , Graphics.COLOR_TRANSPARENT);	
		
		dc.drawLine(BatBarStatic[0],BatBarStatic[1],BatBarStatic[2],BatBarStatic[3]);	
		//System.println("printing bar from: "+BatBarStatic[0]+" to "+BatBarStatic[2]);	
		}	
	}
	function drawDateStatic(dc,Color) {

	}
	function drawHoursStatic(dc,Color) {

						 dc.setColor(Color , Graphics.COLOR_TRANSPARENT);	//minVecTxt
	if(hourVecTxt != null)
	{
	
						dc.drawText(hourVecTxt[0], hourVecTxt[1], ClockFont,hourVecTxt[2] , hourVecTxt[3]);
						
						}
	if(minVecTxt != null) {
						dc.drawText(minVecTxt[0], minVecTxt[1], font_min,minVecTxt[2] , minVecTxt[3]);
						//System.println("printing minute: "+minVecTxt[2]+" on pos "+minVecTxt[1]);
						}
						
		 dc.setColor(DtColor , Graphics.COLOR_TRANSPARENT);		
 		if(MinPoint != null) {					
		dc.drawPoint(MinPoint[0], MinPoint[1]);
		//System.println("printing DOT: "+MinPoint[1]+" on pos "+MinPoint[0]);
		}		
		
		if(MinThick != null) {
		dc.drawLine(MinThick[0],MinThick[1],MinThick[2],MinThick[3]);	
		//System.println("printing thick: "+MinThick[2]+" on pos "+MinThick[1]);	
		}

					
						
						
						

	}
 function drawStepStatic(dc,Color) {
	}

	
    // Handle the partial update event
 function onPartialUpdate( dc ) {
        // If we're not doing a full screen refresh we need to re-draw the background
        // before drawing the updated second hand position. Note this will only re-draw
        // the background in the area specified by the previously computed clipping region.
        
        if(displaySeconds==true)
        {

            
        
         var seconds = System.getClockTime().sec;
        // System.println("update"+seconds);
		var minutes = System.getClockTime().min;
		if(minutes%2!=0)
			{
					seconds = 60-seconds;
				}         
       curClip = getBoundingBox(dc, seconds );
        var bboxWidth = curClip[1][0] - curClip[0][0];
        var bboxHeight = curClip[1][1] - curClip[0][1];
        dc.setClip(curClip[0][0], curClip[0][1], bboxWidth, bboxHeight);
        	   // dc.setPenWidth(1);
	//erase previous
	//dc.setColor(Graphics.COLOR_PINK, BgColor);
 		//dc.drawRectangle(curClip[0][0], curClip[0][1], bboxWidth, bboxHeight);
      drawSeconds(dc,BrColor, seconds);
      //         BgColor=Bg;
     //		BrColor = Barcolor;
     }
    }

    // Compute a bounding box from the passed in points
    function getBoundingBox(dc,secs  ) {
   
   	     var step = Math.floor(dc.getWidth()/60.0);
    var modifier = (dc.getWidth()-step*60)/2;
    var curX = modifier+secs*step; 
   
    //var curX = Math.ceil(secs*dc.getWidth()/60.0);
        var min = [curX-11,dc.getHeight()/2-2];
        var max = [curX+11,dc.getHeight()/2+2];



        return [min, max];
    }
    function getBoundingBox2(dc,secs  ) {
    }    
function drawSeconds(dc,Color,secs)	{ 	
}
 
    function drawBackground(dc) {
     	 
     	 
        dc.setColor(BgColor, BgColor);
		dc.clear();
		dc.setColor(BgColor, BgColor);
		dc.fillRectangle(0, 0, dc.getWidth(), dc.getHeight());
		
		dc.setPenWidth(2);

		drawMinutes(dc,FgColor);



 
    }

    // This method is called when the device re-enters sleep mode.
    // Set the isAwake flag to let onUpdate know it should stop rendering the second hand.
    function onEnterSleep() {
        isAwake = false;
        WatchUi.requestUpdate();
    }

    // This method is called when the device exits sleep mode.
    // Set the isAwake flag to let onUpdate know it should render the second hand.
    function onExitSleep() {
        isAwake = true;


//WatchUi.animate(myString, 50, WatchUi.ANIM_TYPE_LINEAR, 10, 200, 10, null);
        
    }
}
class SliderViewDelegate extends WatchUi.WatchFaceDelegate {
    // The onPowerBudgetExceeded callback is called by the system if the
    // onPartialUpdate method exceeds the allowed power budget. If this occurs,
    // the system will stop invoking onPartialUpdate each second, so we set the
    // partialUpdatesAllowed flag here to let the rendering methods know they
    // should not be rendering a second hand.
    function onPowerBudgetExceeded(powerInfo) {
        System.println( "Average execution time: " + powerInfo.executionTimeAverage );
        System.println( "Allowed execution time: " + powerInfo.executionTimeLimit );
        partialUpdatesAllowed = false;
    }
}
