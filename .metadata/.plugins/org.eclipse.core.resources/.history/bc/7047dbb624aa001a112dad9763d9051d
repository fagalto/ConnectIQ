

using Toybox.Graphics;
using Toybox.Lang;
using Toybox.Math;
using Toybox.System;
using Toybox.Time;
using Toybox.Time.Gregorian;
using Toybox.WatchUi;
using Toybox.Application;
using Toybox.SensorHistory;


var partialUpdatesAllowed = false;

class SliderView extends WatchUi.WatchFace
{
    var font1;
    var font_min;
    var font_min1;
    var font_min2;
    var font_max;
    var isAwake;
    var screenShape;
    var dndIcon;
    var offscreenBuffer;
    var dateBuffer;
    var curClip;
    var screenCenterPoint;
   // var screenHalfPoint;
    var fullScreenRefresh;
    var is24hour;
 
	var fontSize;
	var tempUnits;
	 
    var BgColor;
    var BrColor;   
    var DtColor;
    var FgColor;
    var ThemeColor;
    var ShowBatteryBar;
    var StepCals;
 	var chosenFields;
	var displaySeconds;

	 var dtVecTxt ;
	 var dtVecNum ; 
	 var hourVecTxt;
	 var minVecTxt;
	 var DateDot;
	 var DateThick;
	var MinThick ;
	var MinPoint ;	 
	var	StepThick;
	var	StepDot;						
	var BatBarStatic;
	var StepTxt;	
	var ClockFont; 
	var ClockFont1; 
		var ClockFont2; 	

    function initialize() {
        WatchFace.initialize();
        screenShape = System.getDeviceSettings().screenShape;
        fullScreenRefresh = true;
        partialUpdatesAllowed = ( Toybox.WatchUi.WatchFace has :onPartialUpdate );
    }

    // Configure the layout of the watchface for this device
    function onLayout(dc) {

        font_min1 = WatchUi.loadResource(Rez.Fonts.mari_font_min);
         font_min2 = WatchUi.loadResource(Rez.Fonts.mari_font_min2);
        ClockFont1 = WatchUi.loadResource(Rez.Fonts.teko);
 		ClockFont2 = WatchUi.loadResource(Rez.Fonts.mari_font_max);
 		screenCenterPoint = [dc.getWidth()/2, dc.getHeight()/2];

	}
    // Handle the update event
    function onUpdate(dc) {
        var width;
        var height;
        var screenWidth = dc.getWidth();
        var clockTime = System.getClockTime();
        var minuteHandAngle;
        var hourHandAngle;
        var secondHand;
        var targetDc = null;
         chosenFields = [1,2,3,4,5,6];
         getFields ();
         
          /*
               order in settings defined:       Steps,Calories,Temperature,Battery,HeartRate,Floors,Altitude,Messages
          */
         ShowBatteryBar = false; 
         
         is24hour = System.getDeviceSettings().is24Hour;
         tempUnits = System.getDeviceSettings().temperatureUnits ;
         BgColor = 0x000000;
		 FgColor = 0xFFFFFF;
		 ThemeColor = 0x555555;
		 getColorSettings();
 		drawBackground(dc);

        if(Application.getApp().getProperty("displaySeconds") != null)
        {
        displaySeconds = Application.getApp().getProperty("displaySeconds");
        }   
        else
        	{
        	Application.getApp().setProperty("displaySeconds", displaySeconds);
        	} 		

        if( partialUpdatesAllowed && displaySeconds==true) {
        dc.clearClip();
       
		         var seconds = System.getClockTime().sec;
		           //System.println("update "+seconds);
				var minutes = System.getClockTime().min;
		     drawSeconds(dc,BrColor, seconds);
        } else if ( isAwake ) {
            // Otherwise, if we are out of sleep mode, draw the second hand
            // directly in the full update method.
           // dc.setColor(Graphics.COLOR_RED, Graphics.COLOR_TRANSPARENT);
           // secondHand = (clockTime.sec / 60.0) * Math.PI * 2;
        }

        fullScreenRefresh = false;

    }

    function drawBackground(dc) {
     	 
     	 
        dc.setColor(BgColor, BgColor);
		dc.clear();
		dc.setColor(BgColor, BgColor);
		dc.fillRectangle(0, 0, dc.getWidth(), dc.getHeight());
		
		dc.setPenWidth(2);

		drawHours(dc,FgColor);
		drawMinutes(dc,FgColor);
		drawFields(dc,FgColor);
		
		//todo
		//steps
		//calories
		//heart rate
		//altitude



 
    }
	
	function drawMinutes(dc,Color)	{

	var minutes = System.getClockTime().min.format("%02d");
	dc.setColor(Color,BgColor);
 
	var fsize = dc.getHeight()/4;
	var y = dc.getHeight()/2+fsize/2;
	var x = dc.getWidth()/2+5 ;
	dc.setColor(Color,BgColor);
	renderText(dc,x,y,fsize,minutes,ThemeColor);	
	}
	
	function drawHours(dc,Color)	{
	var hours = System.getClockTime().hour.format("%02d");
	
	var onehour = new Time.Duration(3600);
	var currenth = new Gregorian.Moment(Time.now().value());
	var hourLater =  Gregorian.info(currenth.add(onehour),Time.FORMAT_MEDIUM).hour.format("%02d");
	var hourBefore = Gregorian.info(currenth.subtract(onehour),Time.FORMAT_MEDIUM).hour.format("%02d");
	
	
	//coords
	var fsize = dc.getWidth()/2.54;
	//System.println("gotta:"+fsize);
	var y = dc.getHeight()/2+fsize/2;
	var yb = dc.getHeight()/2-fsize/2-10;
	var ya = dc.getHeight()/2+fsize*1.5+10;
	var x = dc.getWidth()/2-hours.length()*fsize/2.0-fsize/20-5;
	var x2 = dc.getWidth()/2-5;
	dc.setColor(Color,BgColor);
	renderText(dc,x,y,fsize,hours,ThemeColor);
	renderText(dc,x,yb,fsize,hourBefore,Color);
	renderText(dc,x,ya,fsize,hourLater,Color);
	
	RenderShade(dc,x,yb-fsize,x2,yb,BgColor,Color);
	RenderShade(dc,x,ya-fsize,x2,ya,BgColor,Color);
	}	
	
	function drawFields(dc,FieldColor) {
        // chosenFields = [1,2,3,4,5,6];
       
        //Steps,Calories,Temperature,Battery,HeartRate,Floors,Altitude,Messages	
     var x = dc.getWidth()/2+5;
     var y =0;  
     var z=3;
     var fsize = 14;//dc.getHeight()/20.0; 
		     for(var i =0;i<chosenFields.size();i++) {
		     //wez wartoœæ pola
		   	
		      y = dc.getHeight()/6.0+i*fsize*1.5;
		      if(i>2)
		      	{
		      	
		      y = dc.getHeight()-z*fsize*1.5;
		      z--;
		      	}
		     		drawField(dc,x,y,chosenFields[i],FieldColor,fsize);
		     //narysuj pole
		     
		     }
	
	
	}	
	
	function drawField(DrawContext,x,y,fieldType,FieldColor,fontSize) {
	//Steps,Calories,Temperature,Battery,HeartRate,Floors,Altitude,Messages	
	var value =0;

		value = getFieldValue(fieldType);

	renderSymbol(DrawContext,x,y,fontSize,fieldType,FieldColor);
	renderText(DrawContext,x+fontSize+5,y,fontSize,value.toString(),FieldColor);
	
	}
	
	
	function renderText(DrawContext,x,y,size,value,Color)
	{
		var spacing = 0;//size/20;
		//System.println("gotta:"+value);
		var tempPolygons = new[value.length()];
		var valPolygons = new[value.length()];	
		
		spacing = size/20;
		if(spacing<2)
			{
			spacing = 2;
			}	
			for(var i=0;i<value.length();i++)
			{
			tempPolygons = calcDigit(size,value.substring(i,i+1));
			tempPolygons =	PolygonTranslate(tempPolygons,x+i*size/2.0+i*spacing,y);		
			valPolygons[i] = tempPolygons;
			}
			for(var i=0;i<value.length();i++)
			{
			DrawContext.setColor(Color, BgColor);
			DrawContext.fillPolygon(valPolygons[i]);
			}		
		
		}
		function RenderShade(dc,x1,y1,x2,y2,Bg,Fg) {
		x1--;
		y1--;
		x2++;
		y2++;
		dc.setColor(Bg, Bg);
		dc.setPenWidth(1);
		for(var i=x1;i<=x2;i++)
			{
			
			dc.drawLine(i, y1, i, y2);
			i++;
			
			}
		for(var j=y1;j<=y2;j++)
			{
			dc.drawLine(x1, j, x2, j);
			j++;
			}		
		dc.setColor(Fg, Bg);
		
}
	
function renderSymbol(DrawContext,x,y,fontSize,fieldType,FieldColor) {
var s = fontSize;
var polygon = null;
var polygon1 = null;
var polygon2 = null;
var complicatedIcon = new[2];
DrawContext.setColor(ThemeColor, BgColor);
//assume bitmap size is14//38349
		switch ( fieldType ) {
		case 0: //steps
		//polygon = [[4, 0], [4, -1],[5,-1],[5,-2],[6,-5],[6,-9],[5,-10],[1,-10],[0,-9],[0,-8],[1,-7],[3,-7],[3,-4],[2,-3],[1,-2],[1,-1],[2,0]];//definitely to improve
		//polygon = [[3,0],[4,-1],[4,-2],[3,-3],[2,-4],[2,-5],[3,-6],[4,-7],[6,-7],[6,-10],[1,-10],[0,-9],[0,-1],[1,0]];//definitely to improve
		polygon1 = [[3, -2], [4,-3],[4,-4],[2,-6],[2,-10],[4,-12],[5,-12],[7,-13],[7,-14],[6,-15],[1,-15],[0,-12],[0,-5],[1,-5],[1,-3],[2,-2]];
		polygon2 = [[13, -2], [14,-3],[14,-5],[15,-5],[15,-13],[14,-15],[9,-15],[8,-14],[8,-13],[10,-12],[11,-12],[13,-10],[13,-6],[11,-4],[11,-3],[12,-2]];
		//polygon2 = [[15,-5],[15,-11],[14,-13],[9,-13],[8,-12],[8,-11],[10,-10],[11,-10],[13,-8],[13,-5]];
		complicatedIcon = [polygon1,polygon2];
		for(var i =0;i<complicatedIcon.size();i++){
	complicatedIcon[i] =	PolygonTranslate(complicatedIcon[i],x-3*i,y+5*i);	
			
			DrawContext.fillPolygon(complicatedIcon[i]);		
		}
		 
		break;	
		case 1: //Calories
		polygon = [[0, 0], [0,0],[0,0],[0,0]];
		break;	
		case 2: //Temperature
		polygon2 = [[7,0],[8,-1],[8,-4],[7,-5],[7,-7],[10,-7],[7,-7],[7,-10],[10,-10],[7,-10],[7,-13],[10,-13],[7,-13],[7,-14],[6,-15],[4,-15],[3,-14],[3,-5],[2,-4],[2,-1],[3,0],[7,0]];
		polygon2 =	PolygonTranslate(polygon2,x,y);	
		var mercury = [[4,-2],[6,-2],[6,-3],[5,-3],[5,-10],[5,-3],[4,-3],[4,-2]];
		mercury =	PolygonTranslate(mercury,x,y);	
			DrawPolygon(DrawContext,polygon2);
			DrawPolygon(DrawContext,mercury);
			
		break;	
		case 3: //Battery
		var	myStats = System.getSystemStats();
				var batLvl =myStats.battery;

		batLvl=-1*Math.floor(1.3*batLvl/10);
		//System.println(batLvl);
		polygon2 = [[8,0],[8,-13],[6,-13],[6,-15],[2,-15],[2,-13],[0,-13],[0,0],[8,0]];
		polygon2 =	PolygonTranslate(polygon2,x+1,y);	
		var batLvlLine = [[8,-1],[8,batLvl],[2,batLvl],[2,-1],[9,-1]];
		
		batLvlLine =	PolygonTranslate(batLvlLine,x,y);	
		DrawPolygon(DrawContext,polygon2);
		DrawContext.fillPolygon(batLvlLine);
		if(batLvl==-13)
			{
			var batFull = [[6,-14],[2,-14]];
			batFull =	PolygonTranslate(batFull,x,y);	
			DrawPolygon(DrawContext,batFull);
			}		
		break;	
		case 4: //HeartRate
		polygon = [[6,0],[12,-8], [12,-12],[10,-15],[9,-15],[6,-12],[3,-15],[2,-15],[0,-12],[0,-8],[6,0]];
		break;	
		case 5: //Floors
		polygon = [[0, 0], [3,0],[3,-3],[6,-3],[6,-6],[9,-6],[9,-9],[12,-9],[12,-12],[15,-12],[15,-13],[11,-13], [11,-10],[8,-10],[8,-7],[5,-7],[5,-4],[2,-4],[2,-1],[0,-1]];
		break;	
		case 6: //Altitude
		polygon = [[0, 0], [12,0],[9,-13],[6,-5],[4,-10]];
		break;
		case 7: //Messages
		polygon = [[s*0.33, 0], [s, -s*0.67],[s*0.67,-s],[0,-s*0.33]];
		break;	
		default:
		polygon = [[s*0.33, 0], [s, -s*0.67],[s*0.67,-s],[0,-s*0.33]];
		break;										
	}
	if(polygon !=null){
	polygon =	PolygonTranslate(polygon,x,y);	
			DrawContext.setColor(ThemeColor, BgColor);
			DrawContext.fillPolygon(polygon);
	}
			
}


	
		function calcDigit(s,digit)	{
		var tdv = 6.0;
		var mUp = tdv/2.0+0.5;
		var mDn = tdv/2.0-0.5;
		//System.println("gotta:"+mUp+","+mDn);
		var hs = s/2;
		var th = Math.floor(s/tdv);
		 
		//if(th<2){th=2;}
		//System.println("gotta:"+th+","+mUp);
		var xspacing = s/20;
		var polygon = null;
		
		var letter = new[2];
		
			switch ( digit ) {
			case "1":
			polygon = [[hs, 0], [hs, -s],[hs-1.5*th,-s],[hs-1.5*th,-s+th],[hs-th,-s+th],[hs-th,0]];
			break;
			case "2":
			polygon = [[hs, 0], [hs, 0-1*th],[0+th,0-1*th],[0+th,0-mDn*th],[hs,0-mDn*th],[hs,-s],[0,-s],[0,-s+th],[hs-th,-s+th],[hs-th,0-mUp*th],[0,0-mUp*th],[0,0]];
			break;
			case "3":
			polygon = [[hs, 0], [hs, -s],[0,-s],[0,-s+th],[hs-th,-s+th],[hs-th,0-mUp*th],[0+2,0-mUp*th],[0+2,0-mDn*th],[hs-th,0-mDn*th],[hs-th,0-1*th],[0,0-1*th],[0,0]];
			break;
			case "4":
			polygon = [[hs, 0], [hs,-s+1.5*th],[hs-th,-s+1.5*th],[hs-th,0-mUp*th],[0+th,0-mUp*th],[0+th,-s],[0,-s],[0,0-mDn*th],[hs-th,0-mDn*th],[hs-th,0]];
			
			break;
			case "5":
			polygon = [[hs, 0], [hs, 0-mUp*th],[0+th,0-mUp*th],[0+th,-s+th],[hs,-s+th],[hs,-s],[0,-s],[0,0-mDn*th],[hs-th,0-mDn*th],[hs-th,0-1*th],[0,0-1*th],[0,0]];
			//polygon = [[hs, 0], [hs, -s],[hs-1.2*th,-s],[hs-1.2*th,-s+th],[hs-th,-s+th],[hs-th,0]];
			break;
			case "6":
			polygon = [[hs, 0], [hs, 0-mUp*th],[0+th,0-mUp*th],[0+th,-s+th],[hs,-s+th],[hs,-s],[0,-s],[0,0],[0+th,0],[0+th,0-mDn*th],[hs-th,0-mDn*th],[hs-th,0-1*th],[0+th,0-1*th],[0+th,0]];
	
			break;
			case "7":
			polygon = [[hs, 0], [hs, -s],[0,-s],[0,-s+th],[hs-th,-s+th],[hs-th,0]];
			break;
			case "8":
			polygon = [[hs, 0], [hs, -s],[hs-th,-s],[hs-th,0-mUp*th],[0+th,0-mUp*th],[0+th,-s+th],[hs-th,-s+th],[hs-th,-s],[0,-s],[0,0],  [0+th,0],[0+th,0-mDn*th],[hs-th,0-mDn*th],[hs-th,0-1*th],[0+th,0-1*th],[0+th,0]];
	
			break;
			case "9":
			polygon = [[hs, 0],[hs,-s],[hs-th,-s],[hs-th,0-mUp*th],[0+th,0-mUp*th],[0+th,-s+th],[hs-th,-s+th],[hs-th,-s],[0,-s],[0,0-mDn*th],[hs-th,0-mDn*th],[hs-th,0-1*th],[0,0-1*th],[0,0]];
			//polygonHoles[0] = [[hs-th,-s+4*th],[hs-th,-s+3*th],[0+th,-s+3*th],[0+th,-s+4th]];
		
			break;	
			case "0":
			polygon = [[hs, 0], [hs, -s],[hs-th,-s],[hs-th,0-1*th],[0+th,0-1*th],[0+th,-s+th],[hs-th,-s+th],[hs-th,-s],[0,-s],[0,0]];
	
			break;												
			}
		//polygon = [[hs+100, 0+100], [hs+100, -s+100],[hs-2*th+100,-s+100],[hs-2*th+100,-s+th+100],[hs-th+100,-s+th+100],[hs-th+100,0+100]];
	
		return polygon;
	
	
}

function getFieldValue(fieldType) {

var info = ActivityMonitor.getInfo();
var value = 0;

		switch ( fieldType ) {
		case 0: //steps
		value = info.steps+15294;
		break;	
		case 1: //Calories
		value = info.calories;
		break;	
		case 2: //Temperature
				var temp=-55;
				if(Toybox has :SensorHistory)
				{
					if(Toybox.SensorHistory has :getTemperatureHistory)
					{
					temp = Toybox.SensorHistory.getTemperatureHistory({}).next().data.toLong();
					}
				}
				var tMark = "C";
				if(tempUnits==System.UNIT_STATUTE)
					{
					//temp = Math.floor(temp*1.8+32);
					 temp = Math.floor(temp*1.8+32).toNumber();
					tMark = "F";
					}
					value = temp;//Math.floor(temp);
		break;	
		case 3: //Battery
		var	myStats = System.getSystemStats();
					value = myStats.battery;	
		break;	
		case 4: //HeartRate
		value = 207;
		break;	
		case 5: //Floors
		value = 15;
		break;	
		case 6: //Altitude

			var alt =-500;
					
					
					
					if(Toybox has :SensorHistory)
					{		
						if(Toybox.SensorHistory has :getElevationHistory)
						{
						alt = Toybox.SensorHistory.getElevationHistory({}).next().data.toLong();
						}
					}
							if(tempUnits==System.UNIT_STATUTE)
						{
						//temp = Math.floor(temp*1.8+32);
						 alt = alt*3.2808399;
						
						}
			
			
					value = alt;
		break;
		case 7: //Messages
		value = 1;
		break;	
		default:
		value = 0;
		break;										
	}
return value.toNumber().toString();

}
function DrawPolygon(DrawContext,polygon) {
		for(var i=1;i<polygon.size();i++)
			{
			DrawContext.drawLine(polygon[i-1][0], polygon[i-1][1], polygon[i][0], polygon[i][1]);
			}
}

function PolygonTranslate(Polygon,Tx,Ty)
	{
	var s = Polygon.size();
	var tempShifter = new [s];
	
	for( var j = 0; j < Polygon.size(); j++ ) {
			  // System.println("imma translatin"+Polygon[j]+[Tx,Ty]);
			    Polygon[j] =  [Polygon[j][0]+Tx,Polygon[j][1]+Ty];
			}
	return Polygon;	
	}
	
	
	
	function drawSteps(dc,Color,StepCals)	{

	}


	function dayOfWeek(day) {
	
	var days = [1, 2, 3, 4, 5, 6, 7, 8];
	days[0]=null;
	days[1]="Sunday";
	days[2]="Monday";
	days[3]="Tuesday";
	days[4]="Wednesday";
	days[5]="Thursday";
	days[6]="Friday";
	days[7]="Saturday";
	
	return days[day].substring(0,3);

	}		
	function drawDate(dc, Color)	{
	
	}


	function drawBatteryStatic(dc,bw) {
	//BatBarStatic;
	}
	function drawDateStatic(dc,Color) {

	}
	function drawHoursStatic(dc,Color) {				

	}
	 function drawStepStatic(dc,Color) {
	}
	function getColorSettings() {
        if(Application.getApp().getProperty("BackgroundColor") != null)
        {
        BgColor = Application.getApp().getProperty("BackgroundColor");
        }
        else
        	{
        	Application.getApp().setProperty("BackgroundColor", BgColor);
        	}
        	 
      	if(Application.getApp().getProperty("ForegroundColor") != null)
        {
        FgColor = Application.getApp().getProperty("ForegroundColor");
        }
        else
        	{
        	Application.getApp().setProperty("ForegroundColor", FgColor);
        	}      
        if(Application.getApp().getProperty("ThemeColor") != null)
        {
        ThemeColor = Application.getApp().getProperty("ThemeColor");
        
        }   
        else
        	{
        	Application.getApp().setProperty("ThemeColor", ThemeColor);
        	}	
	
	}

	
    // Handle the partial update event
 function onPartialUpdate( dc ) {
        // If we're not doing a full screen refresh we need to re-draw the background
        // before drawing the updated second hand position. Note this will only re-draw
        // the background in the area specified by the previously computed clipping region.
        
        if(displaySeconds==true)
        {

            
        
         var seconds = System.getClockTime().sec;
        // System.println("update"+seconds);
     
       curClip = getBoundingBox(dc, seconds );
        var bboxWidth = curClip[1][0] - curClip[0][0];
        var bboxHeight = curClip[1][1] - curClip[0][1];
        dc.setClip(curClip[0][0], curClip[0][1], bboxWidth, bboxHeight);
        	   // dc.setPenWidth(1);
	//erase previous
	//dc.setColor(Graphics.COLOR_PINK, BgColor);
 		//dc.drawRectangle(curClip[0][0], curClip[0][1], bboxWidth, bboxHeight);
      drawSeconds(dc,BrColor, seconds);
      //         BgColor=Bg;
     //		BrColor = Barcolor;
     }
    }

    // Compute a bounding box from the passed in points
    function getBoundingBox(dc,secs  ) {
   
   	     var step = Math.floor(dc.getWidth()/60.0);
    var modifier = (dc.getWidth()-step*60)/2;
    var curX = modifier+secs*step; 
   
    //var curX = Math.ceil(secs*dc.getWidth()/60.0);
        var min = [curX-11,dc.getHeight()/2-2];
        var max = [curX+11,dc.getHeight()/2+2];



        return [min, max];
    }
    function getBoundingBox2(dc,secs  ) {
    }    
function drawSeconds(dc,Color,secs)	{ 

var secondsAngle = (secs ) * Math.PI * 2;

var thick = generateSecondsThicks(screenCenterPoint,secondsAngle,5);
DrawPolygon(dc,thick);

//System.println([secs,secondsAngle,thick]);
}
 
    function generateSecondsThicks(centerPoint, angle, handLength) {
        // Map out the coordinates of the watch hand
        var ThickLen = 5;
        
        
        var coords = [[centerPoint[0],centerPoint[1]-centerPoint[1]/2+ThickLen],[centerPoint[0],centerPoint[1]-centerPoint[1]/2]];
        var result = new [2];
        var cos = Math.cos(angle);
        var sin = Math.sin(angle);
        System.println([cos,sin]);

        // Transform the coordinates
        for (var i = 0; i < result.size(); i ++) {
            var x = coords[i][0] * cos;
            var y = coords[i][1] * sin;

            result[i] = [ x, y];
        }

        return result;
    } 


    // This method is called when the device re-enters sleep mode.
    // Set the isAwake flag to let onUpdate know it should stop rendering the second hand.
    function onEnterSleep() {
        isAwake = false;
        WatchUi.requestUpdate();
    }

    // This method is called when the device exits sleep mode.
    // Set the isAwake flag to let onUpdate know it should render the second hand.
    function onExitSleep() {
        isAwake = true;


//WatchUi.animate(myString, 50, WatchUi.ANIM_TYPE_LINEAR, 10, 200, 10, null);
        
    }
    function getFields () {
    
   
    var j=0;
   
    for(var i=0;i<6;i++)
    {
    j++;
	     if(Application.getApp().getProperty("Field_"+j) != null) { 
		     	chosenFields[i] = Application.getApp().getProperty("Field_"+j);
		     	}
	         	else{Application.getApp().setProperty("Field_"+j, chosenFields[i]);
	         	} 
	         	
	     }        	         	         	         	         	         	
    }
}
class SliderViewDelegate extends WatchUi.WatchFaceDelegate {
    // The onPowerBudgetExceeded callback is called by the system if the
    // onPartialUpdate method exceeds the allowed power budget. If this occurs,
    // the system will stop invoking onPartialUpdate each second, so we set the
    // partialUpdatesAllowed flag here to let the rendering methods know they
    // should not be rendering a second hand.
    function onPowerBudgetExceeded(powerInfo) {
        System.println( "Average execution time: " + powerInfo.executionTimeAverage );
        System.println( "Allowed execution time: " + powerInfo.executionTimeLimit );
        partialUpdatesAllowed = false;
    }
}
